<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    	img { max-width: 100%; }
    </style>
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>varnishfoo.info</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
    <div class="page-header">
    <h1>Varnish Foo: A book in the making</h1>
    </div>
    <div class="row">
    <div class="col-md-9">
<h1 class="title">Varnish programs and operation</h1>
<p>If you are working with Varnish, you need to know how to get information
from it, how to start and stop it and how to tweak it a bit.</p>
<p>This chapter will cover the basic architecture of Varnish, how Varnish
deals with logs, best practices for running Varnish and debugging your own
issues.</p>
<p>One of the biggest challenges with writing a book about any server-side
software on GNU/Linux in late 2015/early 2016 is that it's a moving target.
Depending on what distribution you are using, and what version, you may or
may not be using Systemd, upstart or System V init scripts. Even within
these categories, things vary. Advise that held true two year ago are
quickly becoming irrelevant.</p>
<p>The upside to all this is that this chapter is - out of necessity - very
clear on what is a Varnish-derived default or tool, and what is related to
packaging. Examples include tools such as <tt class="docutils literal">varnishlog</tt> which is not
related to <tt class="docutils literal">/var/log</tt> or <tt class="docutils literal">journald</tt> at all, while default arguments
specified in <tt class="docutils literal">/etc/default/varnish</tt> is highly distribution-dependent.
Then <tt class="docutils literal">/etc/varnish/default.vcl</tt> falls somewhere in between.</p>
<p>When you're done reading this chapter, you'll know how to distinguish what
goes into Varnish and what comes out in the other end. You'll have an idea
of what it takes to operate Varnish in the long-term and some very basic
tuning needs.</p>
<p>What you will not learn in this chapter is what every single Varnish
parameter is for. Advanced tuning is a topic for a later chapter, as it's
mostly not relevant for every-day operation. Neither will you see much of
the Varnish Configuration Language (VCL). VCL requires a chapter or two all
by itself.</p>
<p>It's worth taking a look at Appendix A, or go directly to
<a class="reference external" href="https://www.varnish-cache.org/trac/wiki/VTLA">https://www.varnish-cache.org/trac/wiki/VTLA</a> and review some of the three
letter acronyms that are all too common in Varnish. They are used to some
degree in this chapter, though hopefully with a decent explanation.</p>
<div class="section" id="architecture">
<h1>Architecture</h1>
<p>Varnish architecture is not just of academic interest. Every single tool
you use is affected by it, and understanding the architecture will
hopefully help you understand why things work the way they do.</p>
<p>Varnish operates using two separate processes. The management process and
the child process. The child is where all the work gets done. A simplified
overview:</p>
<img alt="img/c3/architecture.png" src="img/c3/architecture.png" />
<p>The management process, which is also the parent process, handles
initialization, parsing of VCL, interactive administration through the CLI
interface, and basic monitoring of the child process.</p>
<p>You will notice that the log file is drawn with a dotted line next to the
child process. It might be more correct to draw it directly into the child.
Varnish has two different logging mechanisms. The manager process will
typically log to <cite>syslog</cite>, like you would expect, but the child logs to a
shared memory log instead. This saves Varnish the trouble of worrying
about file locks and generally speeds things up greatly.</p>
<p>The shared memory log, abbreviated shmlog, is a round-robin style log file
which is usually a little less than 100MB large. It is split in two parts.
The smallest bit is the part for counters, used to keep track of any part
of Varnish that could be covered by a number, e.g. number of cache hits,
number of objects, and so forth. This part of the shmlog is named the VSM
and is 1MB by default.</p>
<p>The biggest part of the shmlog is reserved for fifo-tyle VSL log entries,
directly related to requests typically. This is 80MB by default. Once those
80MB are filled, Varnish will continue writing to the log from the top. If
you wish to preserve any of the data, you need to extract it before it's
overwritten. Luckily for us, there are numerous tools designed to do just
this.</p>
<p>The other note-worthy part of the diagram above is how VCL is handled. VCL
is not a traditionally parsed configuration format, but a shim layer on top
of C and the Varnish run time library (VRT). You are not so much
configuring Varnish with VCL as programming it. Once you've written your
VCL file, Varnish will translate it to C and compile it, then link it
directly into the child process.</p>
<p>The observant reader will have noticed that <tt class="docutils literal"><span class="pre">varnish-agent</span></tt> is listed
twice. That is because the Varnish agent both reads the logs and
communicates with Varnish over the CLI protocol. Both <tt class="docutils literal">varnishadm</tt> and
<tt class="docutils literal"><span class="pre">varnish-agent</span></tt> are tools that can influence a running Varnish instance,
while any tool that only works on the shmlog is purely informational and
has no impact on the running Varnish instance. We will look at the agent
shortly.</p>
</div>
<div class="section" id="design-principles-in-varnish">
<h1>Design principles in Varnish</h1>
<p>Varnish changes frequently. Perhaps more frequently than a system
administrator would like. This is part of the design principles of Varnish.</p>
<p>Varnish is designed to work optimally for the most sensible use cases out
there, with as little configuration as possible. It's designed to be fast
and well behaving. But it is not designed to work for all scenarios
perfectly.</p>
<p>One of the consequences of this was that Varnish was designed with
multi-core 64-bit processes from day one. In 2015 this is not particularly
controversial, but it was not quite as easy to justify poor 32-bit support
in 2006. Using potentially thousands of threads was also not very common
back then.</p>
<p>The good news for you is that there is little in Varnish which is the way
it is because it was written once and can't be changed for fear of breaking
configurations. The down side happens to be the same. With most upgrades,
default values will change.</p>
<p>Practical consequences of this is that you generally don't have to worry
too much about explicitly turning on new features that just make sense. You
don't have to fiddle with every tunable parameter because the defaults are
changed as the Varnish community builds new knowledge on what constitute
good defaults.</p>
<p>If you have a normal computer, Varnish is built for that. If you wish to
run Varnish on a Pentium 4 with a CF card as storage, then Varnish is not
built for that. Patches to make it run better on platforms like that are
rejected if they make a mess for the primary use case: Proper
POSIX-operating systems (GNU/Linux, FreeBSD) running on proper hardware
(or in a VM with proper specs).</p>
</div>
<div class="section" id="the-different-types-of-configuration">
<h1>The different types of configuration</h1>
<p>Varnish uses three different types of configuration types. Certain things
must be configured before Varnish starts and can't be changed during
run-time. These settings are very limited, and are provided on the command
line. Even among command line arguments, several can be changed during run
time to some degree. Examples of command line arguments are things like
which working directory to use and how the management interface should be
configured.</p>
<p>The second type configuration primitive Varnish uses is run-time
parameters. These can be changed after Varnish has started, but depending
on the nature of the parameter it could take some time before the change is
visible. Parameters can be changed through the CLI, but need to be added as
a command line argument in a startup script to be permanent.</p>
<p>Parameters usually change some purely operational aspect of Varnish, not
policy. Default values for Varnish parameters are frequently tuned between
Varnish releases as feedback from real-world use reaches developers. As
such, most parameters can be left to the default values. Some examples of
what parameters can modify is the number of threads Varnish can use, the
size of the shared memory log, what user to run as and default timeout
values.</p>
<p>It's worth mentioning that many of the command line arguments passed to
<tt class="docutils literal">varnishd</tt> are really just short-hands for their respective parameters.</p>
<p>The third type of configuration primitive is the Varnish Configuration
Language script, usually just referred to as your VCL or VCL file. This is
where you will specify caching policies, what backends you have and how to
pick a backend. VCL can be changed at run-time with little or no penalty to
performance, but are not retroactive. If your VCL says &quot;cache this for 5
years&quot; and the content is cached, then changing to a CL that says &quot;cache
this for 1 minute&quot; isn't going to alter the content that has already been
cached.</p>
<p>VCL is easily the most complex part of Varnish, but you can get a lot done
with very basic knowledge and a few tools. In this chapter, VCL is not a
focus, but is only briefly mentioned and used to avoid building bad habits.</p>
<dl class="docutils">
<dt>Command line arguments</dt>
<dd>Stored in startup-scripts. Takes effect on (re)starting Varnish.
Some can be modified after startup, some can not. Often just a
short-hand for setting default values for parameters. Examples:
&quot;how much memory should Varnish use&quot;, &quot;what port should the
management interface use&quot;, &quot;what are the initial values for
parameters&quot;</dd>
<dt>Parameters</dt>
<dd>Stored in startup-scripts, but can be changed at run-time. Upon
re-start, the values from the startup scripts are used. Changes
operational aspects of Varnish, often in great detail. Examples:
&quot;how large should the stack for a thread be&quot;, &quot;what are the default
values for cache duration&quot;, &quot;what is the maximum amount of headers
Varnish supports&quot;.</dd>
<dt>Varnish Configuration Language</dt>
<dd>Stored in a separate VCL file, usually in <tt class="docutils literal">/etc/varnish/</tt>. Can be
changed on-the-fly. Uses a custom-made configuration language to
define caching policies. Examples: &quot;Retrieve content for
www.example.com from backend server at prod01.example.net&quot;, &quot;Strip
Cookie headers for these requests&quot;, &quot;Output an error message for
this URL&quot;.</dd>
</dl>
</div>
<div class="section" id="basic-pre-runtime-configuration">
<h1>Basic pre-runtime configuration</h1>
<p>Most aspects of Varnish can be changed during run-time, but there are a
handful of settings that need to be sorted out before you start
<tt class="docutils literal">varnishd</tt> up. Then there are those that are just better to get sorted
out right away.</p>
<p>FIXME: Systemd.</p>
<p>All of these options are handled by command line arguments to <tt class="docutils literal">varnishd</tt>.
These are rarely entered directly, but usually kept in
<tt class="docutils literal">/etc/default/varnish</tt>, <tt class="docutils literal">/etc/sysconfig/varnish</tt> or the systemd
equivalent. Before we look at those files, we'll look at running
<tt class="docutils literal">varnishd</tt> by hand. Whenever one of these files are referenced, remember
that they have different names on different platforms, and we'll get back
to the individual platforms later.</p>
<p>Before we look at the individual options, a few things are worth
mentioning: Varnish hasn't got the best track record of verifying
arguments. Just because Varnish starts with the arguments you provided
doesn't mean Varnish actually used them as you expected. Make sure you
double check if you deviate from the standard usage. Many arguments are
also short-hands for parameters, which we'll investigate in detail.</p>
<p>We'll start with the most important ones, instead of trying an alphabetical
listing. The examples listed here are from Varnish 4.1, which is slightly
changed from Varnish 4.0, notably adding <cite>PROXY</cite> support, which we will
investigate in later chapters.</p>
<p>The most important option is probably <tt class="docutils literal"><span class="pre">-a</span></tt>, as it specifies what port
Varnish listens to. This argument differs somewhat between Varnish 4.0 and
4.1, but for most use cases that change is irrelevant.</p>
<p>For most practical purposes, you will just use <tt class="docutils literal"><span class="pre">-a</span> :80</tt>, but it's worth
noting that you can have Varnish listening on multiple sockets. This is
especially useful in Varnish 4.1 where you can have Varnish listen for
regular HTTP traffic on port 80, and SSL-terminated traffic through the
PROXY protocol on 127.0.0.1:1443 (for example). In Varnish 4.0, this was
accomplished by having a white-space separated list of <tt class="docutils literal">address:port</tt>
pairs:</p>
<pre class="literal-block">
varnishd -b localhost:8080 ... -a &quot;0.0.0.0:80 127.0.0.1:81&quot;
</pre>
<p>In Varnish 4.1, you can supply multiple <tt class="docutils literal"><span class="pre">-a</span></tt> options instead.</p>
<p>Be careful. Varnish 4.0 will still accept multiple <tt class="docutils literal"><span class="pre">-a</span></tt> options, but only
the last one will be used.</p>
<p>An other subtle detail worth noting is that the <tt class="docutils literal">varnishd</tt> default value
for <tt class="docutils literal"><span class="pre">-a</span></tt> is listening to port 80. But we have seen in previous
installations that a default Varnish installation listens on port 6081, not
port 80.</p>
<p>This is because port 6081 is a convention specified in
<tt class="docutils literal">/etc/default/varnish</tt> and similar. Here's an example from a default
Debian Jessie installation's <tt class="docutils literal">/lib/systemd/system/varnish.service</tt>:</p>
<pre class="literal-block">
ExecStart=/usr/sbin/varnishd -a :6081 -T localhost:6082 \
                -f /etc/varnish/default.vcl \
                -S /etc/varnish/secret \
                -s malloc,256m
</pre>
<p>The Varnish community tries to keep roughly the same defaults across
different platforms, so you will most likely find similar default values on
your own platform, whatever it may be.</p>
<p>In addition to telling Varnish where to listen, you need to tell it where
to get content. In the example above <tt class="docutils literal">varnishd <span class="pre">-b</span> localhost:8080</tt> was
used. The <tt class="docutils literal"><span class="pre">-b</span> <span class="pre">&lt;address[:port]&gt;</span></tt> argument is useful in testing, but not
for much more. In almost all other cases you will want to specify an <tt class="docutils literal"><span class="pre">-f</span>
file</tt> option instead. <tt class="docutils literal"><span class="pre">-f</span> file</tt> tells Varnish where to find the VCL file
it should use, and that VCL file will have to list any and all backend
servers Varnish uses. When you use <tt class="docutils literal"><span class="pre">-b</span></tt>, Varnish generates a simple VCL
file for you behind the scenes:</p>
<pre class="literal-block">
# varnishd -b pathfinder.kly.no:6085 -d
Platform: Linux,4.2.0-0.bpo.1-amd64,x86_64,-smalloc,-smalloc,-hcritbit
200 278
-----------------------------
Varnish Cache CLI 1.0
-----------------------------
Linux,4.2.0-0.bpo.1-amd64,x86_64,-smalloc,-smalloc,-hcritbit
varnish-4.0.2 revision bfe7cd1

Type 'help' for command list.
Type 'quit' to close CLI session.
Type 'start' to launch worker process.

start
child (1443) Started
200 0

Child (1443) said Child starts
vcl.show boot
200 67
vcl 4.0;
backend default {
            .host = &quot;pathfinder.kly.no:6085&quot;;
}
</pre>
<p>There are two more rather trivial, but important, options that all proper
Varnish installations use: <tt class="docutils literal"><span class="pre">-T</span></tt> and <tt class="docutils literal"><span class="pre">-S</span></tt>. The <tt class="docutils literal"><span class="pre">-T</span></tt> option specifies a
listening socket for Varnish's management CLI. Since its introduction, the
convention has been to run the CLI interface on <tt class="docutils literal">127.0.0.1:6082</tt>, and
this is seen in most Varnish distributions. However the actual default for
the <tt class="docutils literal">varnishd</tt> binary in Version 4 and newer is a random port and secret
file.</p>
<p>The <tt class="docutils literal"><span class="pre">-S</span></tt> argument lets you specify a file which contains a shared secret
that management tools can use to authenticate to Varnish. This is referred
to as the <cite>secret file</cite> and should contain random data, typically 256 bytes
worth. The content is never sent over the network, but used to verify
clients. All tools that are to interact with Varnish must be able to read
the content of this file.</p>
<p>The best part about both <tt class="docutils literal"><span class="pre">-T</span></tt> and <tt class="docutils literal"><span class="pre">-S</span></tt> is that you don't really have to
think too much about them. <tt class="docutils literal">varnishadm</tt> and other tools that use the
management port can read those arguments directly from the <tt class="docutils literal">shmlog</tt>.
Example:</p>
<pre class="literal-block">
# varnishd -b localhost:8080
# netstat -nlpt
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address      Foreign Address  State PID/Program name
tcp        0      0 127.0.0.1:37860    0.0.0.0:*        LISTEN 2172/varnishd
tcp        0      0 0.0.0.0:80         0.0.0.0:*        LISTEN -
tcp6       0      0 :::80              :::*             LISTEN -
tcp6       0      0 ::1:35863          :::*             LISTEN 2172/varnishd
# varnishadm -T localhost:37860 status
Authentication required
# varnishadm -T localhost:37860 -S /var/lib/varnish/c496eeac1030/_.secret status
Child in state running
# varnishadm status
Child in state running
</pre>
<p>Notice how <tt class="docutils literal">varnishadm</tt> works with zero arguments, but if you start
adding <tt class="docutils literal"><span class="pre">-T</span></tt> you also have to specify the <tt class="docutils literal"><span class="pre">-S</span></tt>. <tt class="docutils literal">varnishadm</tt> and
<tt class="docutils literal"><span class="pre">varnish-agent</span></tt> can re-use multiple options from <tt class="docutils literal">varnishd</tt> (<tt class="docutils literal"><span class="pre">-T</span></tt>,
<tt class="docutils literal"><span class="pre">-S</span></tt>, <tt class="docutils literal"><span class="pre">-n</span></tt>).</p>
<p>Many Varnish installations default to using <tt class="docutils literal"><span class="pre">-S</span> /etc/varnish/secret</tt>.
This is largely for historic reasons, but is a useful habit in case you end
up with multiple Varnish instances over multiple machines.</p>
<p>To summarize:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">-a</span> &lt;listen address&gt;</tt></dt>
<dd>Listen address. Typically set to :80. Format for multiple listening
sockets varies between Varnish 4.0 and 4.1.</dd>
<dt><tt class="docutils literal"><span class="pre">-b</span> <span class="pre">&lt;address[:port]&gt;</span></tt></dt>
<dd>Specify backend address. Mostly for testing, mutually exclusive
with <tt class="docutils literal"><span class="pre">-f</span></tt> (VCL).</dd>
<dt><tt class="docutils literal"><span class="pre">-f</span> &lt;vclfile&gt;</tt></dt>
<dd>Specify what VCL to use at startup.</dd>
<dt><tt class="docutils literal"><span class="pre">-T</span> address:port</tt></dt>
<dd>Set management/CLI listening address. Used for controlling Varnish.
<tt class="docutils literal">varnishd</tt> default is random, but <tt class="docutils literal">127.0.0.1:6082</tt> is a common
value used in default installations.</dd>
<dt><tt class="docutils literal"><span class="pre">-S</span> &lt;secret file&gt;</tt></dt>
<dd>Used to secure the management CLI. Points to a file with random
data that both <tt class="docutils literal">varnishd</tt> and management clients like
<tt class="docutils literal">varnishadm</tt> must have access to. Often set to
<tt class="docutils literal">/etc/varnish/secret</tt>. Shouldn't matter where it is as long as
<tt class="docutils literal">varnishadm</tt> can read it and the shmlog.</dd>
</dl>
</div>
<div class="section" id="other-useful-varnishd-arguments">
<h1>Other useful <tt class="docutils literal">varnishd</tt> arguments</h1>
<p>You almost always want to specify an <tt class="docutils literal"><span class="pre">-s</span></tt> option. This is used to set how
large Varnish's cache will be, and what underlying method is used to cache.
This is an extensive topic, but for now, use <tt class="docutils literal"><span class="pre">-s</span> <span class="pre">malloc,&lt;size&gt;</span></tt>, for
example <tt class="docutils literal"><span class="pre">-s</span> malloc,256M</tt>. For most systems, using <tt class="docutils literal"><span class="pre">-s</span> <span class="pre">malloc,&lt;size&gt;</span></tt>,
where <tt class="docutils literal">&lt;size&gt;</tt> is slightly less than the system memory is a good
practice. We will come back to this in later chapters.</p>
<p>You've seen <tt class="docutils literal">varnishd <span class="pre">-d</span></tt> in examples, and <tt class="docutils literal">varnishd <span class="pre">-F</span></tt> is similar in
that it runs <tt class="docutils literal">varnishd</tt> in the foreground.  <tt class="docutils literal"><span class="pre">-d</span></tt> can be used to test as
it will connect your terminal to the Varnish CLI. <tt class="docutils literal"><span class="pre">-F</span></tt> is less useful, as
you wont be able to control Varnish without running <tt class="docutils literal">varnishadm</tt> in a
different shell. In normal use, both <tt class="docutils literal"><span class="pre">-d</span></tt> and <tt class="docutils literal"><span class="pre">-F</span></tt> are considered
rather exotic.</p>
<p><tt class="docutils literal"><span class="pre">-n</span> dir</tt> is used to control Varnish working directory. If you are running
just one <tt class="docutils literal">varnishd</tt>-instance per host, then you should avoid <tt class="docutils literal"><span class="pre">-n</span></tt>, but
if you have multiple running on the same host, it's important to give them
different <tt class="docutils literal"><span class="pre">-n</span></tt> arguments. The working directory is where Varnish keeps
the shared memory log (and when <tt class="docutils literal"><span class="pre">-S</span></tt> is left to a default: the secret
file). If you change <tt class="docutils literal"><span class="pre">-n</span></tt>, you need to supply that same <tt class="docutils literal"><span class="pre">-n</span></tt> option to
tools such as <tt class="docutils literal">varnishlog</tt> and <tt class="docutils literal">varnishadm</tt>.</p>
<p>We will cover <tt class="docutils literal"><span class="pre">-p</span></tt> and <tt class="docutils literal"><span class="pre">-r</span></tt> extensively shortly, but they are used for
setting run-time parameters.</p>
<p>A common task you have is to verify that your VCL is correct before you try
loading it. This can be done implicitly with the <tt class="docutils literal"><span class="pre">-C</span></tt> option. It will
either give you a syntax error for your VCL or a whole lot of C code, which
happens to be your VCL translated to C:</p>
<pre class="literal-block">
# cat /etc/varnish/test.vcl
vcl 4.0;

broken VCL backend localhost {
        .host = &quot;localhost&quot;;
        .port = &quot;8080&quot;;
}
# varnishd -C -f /etc/varnish/test.vcl
Message from VCC-compiler:
Expected one of
        'acl', 'sub', 'backend', 'director', 'probe', 'import',  or 'vcl'
Found: 'broken' at
('input' Line 3 Pos 1)
broken VCL backend localhost {
######------------------------

Running VCC-compiler failed, exited with 2

VCL compilation failed
# echo $?
2
</pre>
<p>Note that the return-code of <tt class="docutils literal">varnishd <span class="pre">-C</span> <span class="pre">-f</span> vcl</tt> is false if the VCL
fails to compile. Fixing the VCL:</p>
<pre class="literal-block">
# cat /etc/varnish/test-ok.vcl
vcl 4.0;

backend localhost {
        .host = &quot;localhost&quot;;
        .port = &quot;8080&quot;;
}
# varnishd -C -f /etc/varnish/test-ok.vcl
/* ---===### include/vcl.h ###===--- */

/*
 * NB:  This file is machine generated, DO NOT EDIT!
 *
 * Edit and run generate.py instead
 */

struct vrt_ctx;
struct req;
(......)

# echo $?
0
</pre>
<p>A more useful example:</p>
<pre class="literal-block">
# varnishd -C -f /etc/varnish/test.vcl &gt;/dev/null &amp;&amp; echo &quot;VCL OK&quot; || echo &quot;VCL NOT OK&quot;
Message from VCC-compiler:
Expected one of
        'acl', 'sub', 'backend', 'director', 'probe', 'import',  or 'vcl'
Found: 'broken' at
('input' Line 3 Pos 1)
broken VCL backend localhost {
######------------------------

Running VCC-compiler failed, exited with 2

VCL compilation failed
VCL NOT OK
# varnishd -C -f /etc/varnish/test-ok.vcl &gt;/dev/null &amp;&amp; echo &quot;VCL OK&quot; || echo &quot;VCL NOT OK&quot;
VCL OK
</pre>
<p>Perhaps not the prettiest syntax check, but it gets the job done.</p>
<p>You can also provide <tt class="docutils literal"><span class="pre">-i</span></tt> to set an <cite>identity</cite>. This can be used in VCL
to identify a Varnish instance. Defaults to the same value as <tt class="docutils literal"><span class="pre">-n</span></tt>, or
rather: The hostname of the machine.</p>
<p>There are other options, but they are quite advanced and generally best
left alone. We will cover them in more advanced chapters.</p>
</div>
    </div>
    <div class="col-md-3">
    <h3>Read the book</h3>
    <ul>
    <li><a href="index.html">Front Page</a></li>
    <li><a href="chapter-1.html">Chapter 1: Introduction</a></li>
    <li><a href="chapter-2.html">Chapter 2: Working with HTTP caching</a></li>
    <li><a href="chapter-3.html">In progress: Chapter 3: Architecture and operation</a></li>
    <li><a href="appendix-1.html">Appendix A: Varnish Three Letter Acronyms</a></li>
    <li><a href="appendix-2.html">Appendix B: varnishd arguments</a></li>
    <li><a href="appendix-n.html">Appendix N: License</a></li>
    </ul>
    <h3>Resources</h3>
    <ul>
    <li><a href="https://github.com/KristianLyng/varnishfoo">GitHub repo</a></li>
    <li><a href="https://kly.no/">Author's blog - with frequent updates</a></li>
    <li><a href="https://varnish-cache.org/">Official Varnish Cache site</a></li>
    <li><a href="varnishfoo.pdf">PDF version of the book</a></li>
    </ul>
    </div>
    </div>
    </div>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="js/bootstrap.min.js"></script>
  </body>
</html>
